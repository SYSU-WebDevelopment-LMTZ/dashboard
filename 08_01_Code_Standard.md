# 8.1 代码规范

## 一、后台Python代码规范

### 分号
- 不要在行尾加分号, 也不要用分号将两条命令放在同一行。

### 行长度
- 每行不超过80个字符。以下情况除外：
    - 长的导入模块语句
    - 注释里的URL
- 不要使用反斜杠连接行。

### 括号
- 宁缺毋滥地使用括号
- 除非是用于实现行连接，否则不要在返回语句或条件语句中使用括号。不过在元组两边使用括号是可以的

### 缩进
- 用4个空格来缩进代码
- 绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素, 或者使用4空格的悬挂式缩进(这时第一行不应该有参数)

### 空行
- 顶级定义之间空两行, 方法定义之间空一行
- 顶级定义之间空两行, 比如函数或者类定义。方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行

### 空格
- 按照标准的排版规范来使用标点两边的空格
- 括号内不要有空格
- 按照标准的排版规范来使用标点两边的空格
- 不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾)
- 参数列表, 索引或切片的左括号前不应加空格
- 在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, <, >, !=, <>, <=, >=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致
- 当'='用于指示关键字参数或默认参数值时, 不要在其两侧使用空格
- 不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等)

### 注释
- 文档字符串
    - Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号"""( PEP-257 ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范
- 模块
    - 每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板

### 类
- 如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样

### 字符串
- 避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表. (也可以将每个子串写入一个 cStringIO.StringIO 缓存中.)
- 在同一个文件中, 保持使用字符串引号的一致性. 使用单引号'或者双引号"之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查
- 为多行字符串使用三重双引号"""而非三重单引号'''. 当且仅当项目中使用单引号'来引用字符串时, 才可能会使用三重'''为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号""". 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致

### 文件和sockets
- 在文件和sockets结束时, 显式的关闭它

### TODO注释
- 为临时代码使用TODO注释, 它是一种短期解决方案

### 导入格式
- 每个导入应该独占一行
- 导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:
    - 标准库导入
    - 第三方库导入
    - 应用程序指定导入
- 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写

### 语句
- 通常每个语句应该独占一行

### 命名
- 用单下划线(_)开头表示模块变量或函数是protected的
- 用双下划线(__)开头的实例变量或方法表示类内私有
- 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块
- 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py)